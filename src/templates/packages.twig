<?php

declare(strict_types=1);

namespace ComposerPackages;

use Composer\Package\CompletePackage;
use Composer\Package\PackageInterface;
use Composer\Package\Loader\ArrayLoader;
use \Generator;

/**
 * This class is generated by drupol/composer-packages.
 *
 * This file is overwritten at every run of `composer install` or `composer update`.
 */
final class Packages implements \Countable, \IteratorAggregate
{
    public const GENERATED_AT = {{ generatedAt }};
    public const ROOT_PACKAGE_NAME = '{{ rootPackageName }}';

    private const PACKAGES = {{ packages|export }};
    private const REGEX_PACKAGES = '#^(?|
{% for package, bundles in regex %}
        {{ package }}
    {% for package_name in bundles %}
        {{ package_name }}
    {% endfor %}
    )|
{% endfor %}
    )$#x';

    private static Packages $instance;

    public function count(): int
    {
        return \count(self::PACKAGES);
    }

    /**
     * Get a package.
     *
     * @return null|CompletePackage
     *   A Composer package.
     */
    public static function get(string $name): ?CompletePackage
    {
        if (false !== preg_match(self::REGEX_PACKAGES, $name, $package)) {
            return self::toPackage($package['MARK']);
        }

        return null;
    }

{% for name, package in packages %}
    /**
     * Get the package "{{ name }}".
     *
     * @return CompletePackage
     *   A Composer package.
     */
    public static function {{ name|camelize }}(): PackageInterface
    {
        return self::get('{{ name }}');
    }

{% endfor %}
    /**
     * {@inheritdoc}
     *
     * @return CompletePackage[]|Generator
     */
    public static function find(callable $callable): Generator
    {
        foreach (self::getInstance() as $package) {
            if ($callable($package) === true) {
                yield $package;
            }
        }
    }

    /**
     * {@inheritdoc}
     *
     * @return Generator<string, CompletePackage>
     */
    public function getIterator(): Generator
    {
        foreach (self::PACKAGES as $key => $package) {
            yield $key => (new ArrayLoader())->load($package);
        }
    }

    /**
     * Package generator as array, keyed by their name.
     *
     * @return Generator<string, array>
     */
    public static function packages(): Generator
    {
        yield from self::PACKAGES;
    }

    /**
     * Get an instance.
     *
     * @return Packages
     *   An instance of the class.
     */
    private static function getInstance(): self
    {
        if (null !== self::$instance) {
            return self::$instance;
        }

        self::$instance = new self();

        return self::$instance;
    }

    /**
     * @param string $package
     *   The package name.
     *
     * @return CompletePackage|PackageInterface
     *   A Composer package.
     */
    private static function toPackage(string $package): PackageInterface
    {
        return (new ArrayLoader())->load(self::PACKAGES[$package]);
    }

    /**
    * When it comes to check upon packages, you cannot rely on the presence of the static generated method.
    * You need a proper handling to avoid a non existing method call.
    *
    * @internal
    */
    public static function __callStatic(string $name, $args): ?PackageInterface
    {
        return null;
    }
}
