<?php

declare(strict_types=1);

namespace ComposerPackages;

use Composer\Package\CompletePackage;
use \Generator;

/**
 * This class is generated by drupol/composer-packages.
 *
 * This file is overwritten at every run of `composer install` or `composer update`.
 */
final class Dependencies implements \IteratorAggregate
{
    public const GENERATED_AT = {{ generatedAt }};
    public const ROOT_PACKAGE_NAME = '{{ rootPackageName }}';

    private const DEPENDENCIES = {{ packageDeps|export }};
    private const REGEX_DEPENDENCIES = '#^(?|
{% for package, bundles in regex %}
        {{ package }}
    {% for package_name in bundles %}
        {{ package_name }}
    {% endfor %}
    )|
{% endfor %}
    )$#x';

    /**
     * @param string $name
     *   A package name.
     *
     * @return string[]|Generator
     *   The package dependencies.
     */
    public static function get(string $name): Generator
    {
        yield from self::getDependencies($name);
    }

{% for type, data in packageDeps %}
    /**
     * Get dependencies of packages "{{ type }}".
     *
     * @return string[]|Generator
     *   The package dependencies.
     */
    public static function {{ type|camelize }}(): Generator
    {
        yield from self::getDependencies('{{ type }}');
    }

{% endfor %}
    /**
     * {@inheritdoc}
     *
     * @return Generator<int, CompletePackage>
     */
    public function getIterator(): Generator
    {
        foreach (\array_keys(self::DEPENDENCIES) as $name) {
            yield $name => \iterator_to_array(self::getDependencies(self::DEPENDENCIES[$name]));
        }
    }

    /**
     * Get the dependencies of a package.
     *
     * @param string $package_name
     *   The package name.
     *
     * @return string[]|Generator
     *   The package dependencies.
     */
    private static function getDependencies(string $package_name): Generator
    {
        if (preg_match(self::REGEX_DEPENDENCIES, $package_name, $package)) {
            yield from self::DEPENDENCIES[$package['MARK']];
        }
    }

    /**
     * When it comes to check upon custom dependencies, you cannot rely on the presence of the static generated method.
     * You need a proper handling to avoid a non existing method call.
     *
     * @internal
     */
    public static function __callStatic(string $name, $args): Generator
    {
        yield from [];
    }
}
