<?php

declare(strict_types=1);

namespace ComposerPackages;

use Composer\Package\CompletePackage;
use Composer\Package\Loader\ArrayLoader;
use \Generator;

/**
 * This class is generated by drupol/composer-packages.
 *
 * This file is overwritten at every run of `composer install` or `composer update`.
 */
final class Types implements \Countable, \IteratorAggregate
{
    public const GENERATED_AT = {{ generatedAt }};
    public const ROOT_PACKAGE_NAME = '{{ rootPackageName }}';

    private const TYPES = {{ types|export }};

    public function count(): int
    {
        return \count(self::TYPES);
    }

    /**
     * @param string $type
     *
     * @return CompletePackage[]|Generator
     *   A packages generator.
     */
    public static function get(string $type): Generator
    {
        $packages = self::TYPES[$type] ?? [];

        yield from self::getPackages($packages);
    }

{% for type, data in types %}
    /**
     * Get packages of type "{{ type }}".
     *
     * @return CompletePackage[]|Generator
     *   A packages generator.
     */
    public static function {{ type|camelize }}(): Generator
    {
        yield from self::getPackages(self::TYPES['{{ type }}']);
    }

{% endfor %}
    /**
     * {@inheritdoc}
     *
     * @return \Generator<int, CompletePackage>
     */
    public function getIterator(): \Generator
    {
        foreach (\array_keys(self::TYPES) as $type) {
            yield $type => \iterator_to_array(self::getPackages(self::TYPES[$type]));
        }
    }

    /**
     * Convert an array of packages into an array of Composer package objects.
     *
     * @param array $packages
     *   The array of packages.
     *
     *
     * @return CompletePackage[]|\Generator
     *   A package generator.
     */
    private static function getPackages(array $packages): \Generator
    {
        foreach ($packages as $package) {
            yield (new ArrayLoader())->load($package);
        }
    }

    /**
     * When it comes to check upon custom types, you cannot rely on the presence of the static generated method.
     * You need a proper handling to avoid a non existing method call.
     *
     * @internal
     */
    public static function __callStatic(string $name, $args): \Generator
    {
        yield from [];
    }
}
