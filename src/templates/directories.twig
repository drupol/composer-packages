<?php

declare(strict_types=1);

namespace ComposerPackages;

use Composer\Package\CompletePackage;
use Composer\Package\PackageInterface;
use Composer\Package\Loader\ArrayLoader;

/**
 * This class is generated by drupol/composer-packages.
 *
 * This file is overwritten at every run of `composer install` or `composer update`.
 */
final class Directories implements \Countable, \IteratorAggregate
{
    public const GENERATED_AT = {{ generatedAt }};
    public const ROOT_PACKAGE_NAME = '{{ rootPackageName }}';

    private const DIRECTORIES = {{ directories|export }};
    private const REGEX_DIRECTORIES = '#^(?|
{% for package, bundles in regex %}
        {{ package }}
    {% for packageName in bundles %}
        {{ packageName }}
    {% endfor %}
    )|
{% endfor %}
    )$#x';

    /**
     * {@inheridoc}
     */
    public function count(): int
    {
        return \count(self::DIRECTORIES);
    }

    /**
     * Get a directory.
     *
     * @param string $name
     *
     * @return null|string
     *   A Package directory.
     */
    public static function get(string $name): ?string
    {
        if (preg_match(self::REGEX_DIRECTORIES, $name, $directory)) {
            return self::DIRECTORIES[$directory['MARK']] ?? null;
        }

        return null;
    }

{% for name, dir in directories %}
    /**
     * Get the package "{{ name }}".
     *
     * @return null|strings
     *   The package installation directory.
     */
    public static function {{ name|camelize }}(): ?string
    {
        return self::get('{{ name }}');
    }

{% endfor %}
    /**
     * {@inheritdoc}
     */
    public function getIterator(): \Generator
    {
        yield from self::DIRECTORIES;
    }

    /*
     * When it comes to check upon directories, you cannot rely on the presence of the static generated method.
     * You need a proper handling to avoid a non existing method call.
     * @internal
     */
    public static function __callStatic(string $name, $args): ?string
    {
        return null;
    }
}
